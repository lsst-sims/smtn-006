"""
This script reads in the HEALPIX maps generated by

stellar_density_get_arrays.py
stellar_density_control_arrays.py

and creates plots of them.
"""

from __future__ import with_statement

import matplotlib
matplotlib.use('Agg')

import numpy as np
import healpy as hp
import matplotlib.pyplot as plt

import time

import os

if __name__ == "__main__":

    t_start = time.time()

    # user-specified resolution.  Just make sure that it matches with
    # stellar_density_get_arrays.py and stellar_density_control_arrays.py
    NSIDE = 64

    n_bounds = 17  # number of magnitude bins

    n_control_jobs = 32  # number of independent jobs run with
                         # stellar_density_control_arrays.py

    n_pix = hp.nside2npix(NSIDE)

    plt.figsize = (30,30)

    model_dir = "nside64_model_txt"  # where the ...get_arrays.py maps are
    control_dir = "nside64_control_txt"  # where ...control_arrays.py maps are
    fig_dir = "fig_test"  # where plots will be put
    dtype = np.dtype([('ct', float)])

    margins = (0.01, 0.01, 0.01, 0.01)
    cticks = np.arange(-1.0,6.0,1.0)
    clabels = ['%d' % int(cc) for cc in cticks]

    for name in ('u', 'g', 'r', 'i', 'z', 'y'):
        file_ct = 0
        n_cols_max = 2
        n_rows_max = 3
        col = 0
        row = 0
        fignum = 0
        for ibound in range(n_bounds):

            control_data = None
            for ijob in range(n_control_jobs):
                file_name = os.path.join(control_dir,
                                         "healpix_control_grid_%s_%d_job%d.txt" % (name, ibound, ijob))

                data = np.genfromtxt(file_name, dtype=dtype)
                if control_data is None:
                    control_data = data['ct']
                else:
                    control_data += data['ct']

            file_name = os.path.join(model_dir, "healpix_grid_%s_%d.txt" % (name, ibound))

            with open(file_name, "r") as input_file:
                lines = input_file.readlines()
                fig_title = lines[0].replace('# ','').replace('\n','')
                nside_test = int(lines[1].split()[2])
                assert nside_test == NSIDE

            data = np.genfromtxt(file_name, dtype=dtype)
            assert len(data['ct']) == n_pix
            assert len(control_data) == n_pix

            if fignum==0:
                plt.figsize = (30, 30)
                fignum = 1


            log_data = np.log10(data['ct']+0.1)
            c_min = log_data.min()
            c_max = log_data.max()

            log_input = np.log10(control_data+0.1)
            if log_input.min() < c_min:
                c_min = log_input.min()
            if log_input.max() > c_max:
                c_max = log_input.max()

            cticks = np.arange(c_min, c_max, 0.2*(c_max-c_min))
            clabels = ['%.2f' % cc for cc in cticks]

            hp.mollview(log_data, title=fig_title,
                        sub=(3,2,fignum), cbar=False, margins=margins)
            hp.graticule(dpar=10, dmer=20, verbose=False)
            ax = plt.gca()
            im = ax.get_images()[0]

            cb = plt.colorbar(im)
            cb.set_ticks(cticks)
            cb.set_ticklabels(clabels)
            cb.set_clim(vmin=c_min, vmax=c_max)
            cb.draw_all()
            fignum += 1


            hp.mollview(log_input, title=fig_title+' input',
                        sub=(3,2,fignum), cbar=False, margins=margins)
            hp.graticule(dpar=10, dmer=20, verbose=False)
            ax = plt.gca()
            im = ax.get_images()[0]

            cb = plt.colorbar(im)
            cb.set_ticks(cticks)
            cb.set_ticklabels(clabels)
            cb.set_clim(vmin=c_min, vmax=c_max)
            cb.draw_all()

            fignum += 1
            if fignum >= n_cols_max*n_rows_max or ibound==n_bounds-1:
                out_name = os.path.join(fig_dir, "%s_density_%d.png" % (name, file_ct))
                #plt.tight_layout()
                plt.savefig(out_name)
                plt.close()
                fignum=0
                file_ct += 1

    print 'took ',time.time()-t_start
